package com.Library;import com.Library.common.ValidationException;import com.Library.dtos.BookDTO;import com.Library.models.Book;import com.Library.models.repositories.BookRepository;import com.Library.service.BookService;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.junit.jupiter.MockitoExtension;import org.mockito.stubbing.OngoingStubbing;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Optional;import static org.junit.jupiter.api.Assertions.*;import static org.mockito.ArgumentMatchers.anyLong;import static org.mockito.Mockito.*;@ExtendWith(MockitoExtension.class)@Slf4jpublic class BooksServiceTests {  @InjectMocks  private BookService bookService;  @Mock  BookRepository bookRepository;  private Book existingBookEntity;  private  BookDTO inputBookDTO;  private Book savedBookEntity;  @BeforeEach  void setUp() {    existingBookEntity = new Book();    existingBookEntity.setTitle("Old Title");    existingBookEntity.setAuthor("Old Author");    existingBookEntity.setIsbn("Old ISBN");    existingBookEntity.setPublicationYear(2020);    // Mocking the input BookDTO     inputBookDTO = new BookDTO();    inputBookDTO.setTitle("Edited Title");    inputBookDTO.setAuthor("Edited Author");    inputBookDTO.setIsbn("Edited ISBN");    inputBookDTO.setPublicationYear(2024);    // Mocking the saved book entity     savedBookEntity = new Book();    savedBookEntity.setTitle("Edited Title");    savedBookEntity.setAuthor("Edited Author");    savedBookEntity.setIsbn("Edited ISBN");    savedBookEntity.setPublicationYear(2024);  }  @Test  @DisplayName("Find_oneBook")  void findOneBookTest() throws Exception {    Book mockBook = new Book();    mockBook.setId(1L);    lenient().when(bookRepository.findById(1L)).thenReturn(Optional.of(mockBook));    BookDTO foundBook = bookService.findOneBook(1L);    verify(bookRepository, times(1)).findById(1L);    assertNotNull(foundBook, "Returned BookDTO should not be null");    assertEquals(1L, foundBook.getId(), "Returned BookDTO id should match");    log.info("\n :::::::::::: Success saved new Book tests ::::: \n");  }  @Test  @DisplayName("Find_oneBook - Book not found")  void findOneBookNotFoundTest() throws Exception {    bookService.saveSingleBook(inputBookDTO);    lenient().when(bookRepository.findById(1L)).thenReturn(Optional.of(savedBookEntity));    assertThrows(ValidationException.class, () -> bookService.findOneBook(1L),            "ValidationException should be thrown when book is not found");    log.info("\n :::::::::::: Book not found test ::::: \n");  }  @Test  @DisplayName("Save_OneBook")  void saveSingleBookTests() throws Exception {    lenient().when(bookRepository.save(any(Book.class))).thenReturn(savedBookEntity);    BookDTO savedBook= bookService.saveSingleBook(inputBookDTO);    verify(bookRepository, times(1)).save(any(Book.class));    assertNotNull(savedBook, "Returned BookDTO should not be null");    assertEquals("Test Title", savedBook.getTitle(), "Returned BookDTO title should match");    assertEquals("Test Author", savedBook.getAuthor(), "Returned BookDTO author should match");    log.info("\n :::::::::::: Save single Book test ::::: \n");  }  @Test  @DisplayName("Save_singleBook - Error while saving")  void saveSingleBookErrorTest() {    lenient().when(bookRepository.save(any(Book.class))).thenReturn(new Book());    assertThrows(ValidationException.class, () -> bookService.saveSingleBook(inputBookDTO),            "ValidationException should be thrown when there's an error while saving");    log.info("\n :::::::::::: Save single Book - Error while saving test ::::: \n");  }  @Test  @DisplayName("Edit_singleBook")  void editSingleBookTest() throws Exception {    BookDTO editedBookDTO = bookService.editSingleBook(inputBookDTO, 1L);    verify(bookService, times(1)).findOneBook(1L);    verify(bookService, times(1)).saveSingleBook(bookService.entityToDto(savedBookEntity));    assertNotNull(editedBookDTO, "Returned BookDTO should not be null");    assertEquals("Edited Title", editedBookDTO.getTitle(), "Returned BookDTO title should match");    assertEquals("Edited Author", editedBookDTO.getAuthor(), "Returned BookDTO author should match");    assertEquals("Edited ISBN", editedBookDTO.getIsbn(), "Returned BookDTO ISBN should match");    assertEquals(2024, editedBookDTO.getPublicationYear(), "Returned BookDTO publication year should match");    log.info("\n :::::::::::: Edit single Book test ::::: \n");  }  @Test  @DisplayName("Edit_singleBook - Book not found")  void editSingleBookNotFoundTest() throws Exception {    assertThrows(ValidationException.class, () -> bookService.editSingleBook(new BookDTO(), 1L),            "ValidationException should be thrown when book is not found");    log.info("\n :::::::::::: Edit single Book - Book not found test ::::: \n");  }  @Test  @DisplayName("Delete_singleBook")  void deleteSingleBookTest() throws Exception {    bookService.saveSingleBook(inputBookDTO);    lenient().when(bookService.findOneBook(1L)).thenReturn(bookService.entityToDto(existingBookEntity));    bookService.deleteSingleBook(1L);    verify(bookService, times(1)).findOneBook(1L);    verify(bookRepository, times(1)).deleteById(1L);    log.info("\n :::::::::::: Delete single Book test ::::: \n");  }  @Test  @DisplayName("Delete_singleBook - Book not found")  void deleteSingleBookNotFoundTest() throws Exception {    lenient().when(bookService.findOneBook(anyLong())).thenReturn(null);    assertThrows(ValidationException.class, () -> bookService.deleteSingleBook(1L),            "ValidationException should be thrown when book is not found");    log.info(":::::::::::: Delete single Book - Book not found test ::::: \n");  }}