package com.Library.service;import com.Library.common.ValidationException;import com.Library.dtos.BookDTO;import com.Library.models.Book;import com.Library.models.repositories.BookRepository;import jakarta.transaction.Transactional;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import org.springframework.stereotype.Service;import reactor.core.publisher.Flux;import java.util.ArrayList;import java.util.List;import java.util.NoSuchElementException;@Servicepublic class BookService {  private final BookRepository bookRepository;  public BookService(@Autowired BookRepository bookRepository){     this.bookRepository = bookRepository;  }  public Flux<BookDTO> findAllBooks(){    List<Book>  booksEntity= bookRepository.findAll();    List<BookDTO> DTOs= new ArrayList<>();    for ( Book entity : booksEntity){             DTOs.add(entityToDto(entity));    }    return Flux.fromIterable(DTOs);  }  @Cacheable("books")  public BookDTO findOneBook(Long bookId) throws Exception {    try    {       return entityToDto(bookRepository.findById(bookId).get());    } catch (NoSuchElementException e){      throw new ValidationException("No Book be founded matches your entered id  >>  "+ e.getMessage()) ;    }  }  @Transactional(rollbackOn = ValidationException.class)  public BookDTO saveSingleBook(BookDTO bookdto) throws Exception {    try{       return entityToDto( bookRepository.save(DTO_toEntity(bookdto)) );    }catch(Exception e){      throw new ValidationException("Error exists while saving the new book >>  " + e.getMessage());    }  }  @Transactional(rollbackOn = ValidationException.class)  @CachePut("books")  public BookDTO editSingleBook(BookDTO bookDto,Long bookId) throws Exception {    BookDTO bookDTOResponse=  findOneBook(bookId);    if(bookDTOResponse!=null) {      bookDTOResponse.setAuthor(bookDto.getAuthor());      bookDTOResponse.setIsbn(bookDto.getIsbn());      bookDTOResponse.setTitle(bookDto.getTitle());      bookDTOResponse.setPublicationYear(bookDto.getPublicationYear());      saveSingleBook (bookDTOResponse);      return bookDTOResponse;    }else{      throw new ValidationException("No Book be founded matches your entered id  ") ;    }  }  @Transactional(rollbackOn = ValidationException.class)  @CacheEvict("books")  public void deleteSingleBook(Long bookId) throws Exception {    try    {      if(findOneBook(bookId) != null)  bookRepository.deleteById(bookId);    }catch (Exception e){        throw new ValidationException("No Book be founded matches your entered id   >>   "+ e.getMessage());    }  }  public BookDTO entityToDto(Book book){    BookDTO dto= new BookDTO();    dto.setId(book.getId());    dto.setAuthor(book.getAuthor());    dto.setPublicationYear(book.getPublicationYear());    dto.setIsbn(book.getIsbn());    dto.setTitle(book.getTitle());    return dto;  }  public Book DTO_toEntity(BookDTO bookDTO){    Book entity= new Book();    entity.setId(bookDTO.getId());    entity.setAuthor(bookDTO.getAuthor());    entity.setPublicationYear(bookDTO.getPublicationYear());    entity.setIsbn(bookDTO.getIsbn());    entity.setTitle(bookDTO.getTitle());      return entity;  }}