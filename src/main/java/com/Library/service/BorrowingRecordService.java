package com.Library.service;import com.Library.common.ValidationException;import com.Library.dtos.BookDTO;import com.Library.dtos.BorrowingRecordDTO;import com.Library.dtos.PatronDTO;import com.Library.models.BorrowingRecord;import com.Library.models.repositories.BorrowingRecordRepository;import jakarta.transaction.Transactional;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.Optional;@Servicepublic class BorrowingRecordService {  private final BorrowingRecordRepository borrowingRecordRepository;  private final BookService bookService;  private final PatronService patronService;  public BorrowingRecordService(@Autowired BorrowingRecordRepository borrowingRecordRepository, @Autowired BookService bookService ,@Autowired PatronService patronService){    this.borrowingRecordRepository  = borrowingRecordRepository;    this.bookService= bookService;    this.patronService= patronService;  }  public BorrowingRecordDTO saveSingleBorrow(BorrowingRecordDTO borrowingRecordDTO , Long bookId,Long patronId ) throws ValidationException {    try{       if(findBookById(bookId).isEmpty()) throw new ValidationException("No matches any Books by  >>  Book ID   >> " + bookId);       if(findPatronById(patronId).isEmpty()) throw new ValidationException("No matches any Patrons by  >>  Patron ID   >> " + patronId);      return entityToDto( borrowingRecordRepository.save(DTO_toEntity(borrowingRecordDTO,bookId, patronId)));    }catch(Exception e){      throw new ValidationException("Error exists while saving the new borrowing record >>  " + e.getMessage());    }  }  public BorrowingRecordDTO editSingleBorrowingRecord(BorrowingRecordDTO borrowingRecordDTO , Long bookId,Long patronId) throws ValidationException {    Optional<BorrowingRecord> recordResponse= borrowingRecordRepository.findById(borrowingRecordDTO.getId());    if(recordResponse.isPresent()) {      BorrowingRecordDTO new_DTO= entityToDto(recordResponse.get());      new_DTO.setReturnDate(borrowingRecordDTO.getReturnDate());      new_DTO.setBorrowingDate(borrowingRecordDTO.getBorrowingDate());      saveSingleBorrow (new_DTO,bookId,patronId);      return new_DTO;    }else{      throw new ValidationException("No Borrow Record be founded matches your entered id  ") ;    }  }  private Optional<BookDTO> findBookById(Long bookId) throws Exception {      return Optional.of( bookService.findOneBook(bookId) );  }  private Optional<PatronDTO> findPatronById(Long patronId) throws Exception {     return Optional.of(patronService.findOnePatron(patronId));  }  private BorrowingRecordDTO entityToDto(BorrowingRecord booBorrowingRecord){    BorrowingRecordDTO borrowingRecordDTO = new BorrowingRecordDTO();    borrowingRecordDTO.setBorrowingDate(booBorrowingRecord.getBorrowingDate());    borrowingRecordDTO.setReturnDate(booBorrowingRecord.getReturnDate());    borrowingRecordDTO.setId(borrowingRecordDTO.getId());    return borrowingRecordDTO;  }  private BorrowingRecord DTO_toEntity(BorrowingRecordDTO borrowingRecordDTO , Long bookId,Long patronId ) throws Exception {    if(findBookById(bookId).isEmpty()) throw new ValidationException("No matches any Books by  >>  Book ID   >> " + bookId);    if(findPatronById(patronId).isEmpty()) throw new ValidationException("No matches any Patrons by  >>  Patron ID   >> " + patronId);    BorrowingRecord entity= new BorrowingRecord();    entity.setBook(bookService.DTO_toEntity( findBookById(bookId).get() ));    entity.setBorrowingDate(borrowingRecordDTO.getBorrowingDate());    entity.setReturnDate(borrowingRecordDTO.getReturnDate());    entity.setPatron(patronService.DTO_TO_Entity(findPatronById(patronId).get()));    return entity;  }}